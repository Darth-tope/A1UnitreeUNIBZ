/* LCM type definition class file
 * This file was automatically generated by lcm-gen
 * DO NOT MODIFY BY HAND!!!!
 */

package slam_planner;
 
import java.io.*;
import java.util.*;
import lcm.lcm.*;
 
public final class HighState implements lcm.lcm.LCMEncodable
{
    public byte levelFlag;
    public short commVersion;
    public short robotID;
    public int SN;
    public byte bandWidth;
    public byte mode;
    public slam_planner.IMU imu;
    public float forwardSpeed;
    public float sideSpeed;
    public float rotateSpeed;
    public float bodyHeight;
    public float updownSpeed;
    public float forwardPosition;
    public float sidePosition;
    public slam_planner.Cartesian footPosition2Body[];
    public slam_planner.Cartesian footSpeed2Body[];
    public short footForce[];
    public short footForceEst[];
    public int tick;
    public byte wirelessRemote[];
    public int reserve;
    public int crc;
 
    public HighState()
    {
        footPosition2Body = new slam_planner.Cartesian[4];
        footSpeed2Body = new slam_planner.Cartesian[4];
        footForce = new short[4];
        footForceEst = new short[4];
        wirelessRemote = new byte[40];
    }
 
    public static final long LCM_FINGERPRINT;
    public static final long LCM_FINGERPRINT_BASE = 0x286d5f4437c184dcL;
 
    static {
        LCM_FINGERPRINT = _hashRecursive(new ArrayList<Class<?>>());
    }
 
    public static long _hashRecursive(ArrayList<Class<?>> classes)
    {
        if (classes.contains(slam_planner.HighState.class))
            return 0L;
 
        classes.add(slam_planner.HighState.class);
        long hash = LCM_FINGERPRINT_BASE
             + slam_planner.IMU._hashRecursive(classes)
             + slam_planner.Cartesian._hashRecursive(classes)
             + slam_planner.Cartesian._hashRecursive(classes)
            ;
        classes.remove(classes.size() - 1);
        return (hash<<1) + ((hash>>63)&1);
    }
 
    public void encode(DataOutput outs) throws IOException
    {
        outs.writeLong(LCM_FINGERPRINT);
        _encodeRecursive(outs);
    }
 
    public void _encodeRecursive(DataOutput outs) throws IOException
    {
        outs.writeByte(this.levelFlag); 
 
        outs.writeShort(this.commVersion); 
 
        outs.writeShort(this.robotID); 
 
        outs.writeInt(this.SN); 
 
        outs.writeByte(this.bandWidth); 
 
        outs.writeByte(this.mode); 
 
        this.imu._encodeRecursive(outs); 
 
        outs.writeFloat(this.forwardSpeed); 
 
        outs.writeFloat(this.sideSpeed); 
 
        outs.writeFloat(this.rotateSpeed); 
 
        outs.writeFloat(this.bodyHeight); 
 
        outs.writeFloat(this.updownSpeed); 
 
        outs.writeFloat(this.forwardPosition); 
 
        outs.writeFloat(this.sidePosition); 
 
        for (int a = 0; a < 4; a++) {
            this.footPosition2Body[a]._encodeRecursive(outs); 
        }
 
        for (int a = 0; a < 4; a++) {
            this.footSpeed2Body[a]._encodeRecursive(outs); 
        }
 
        for (int a = 0; a < 4; a++) {
            outs.writeShort(this.footForce[a]); 
        }
 
        for (int a = 0; a < 4; a++) {
            outs.writeShort(this.footForceEst[a]); 
        }
 
        outs.writeInt(this.tick); 
 
        outs.write(this.wirelessRemote, 0, 40);
 
        outs.writeInt(this.reserve); 
 
        outs.writeInt(this.crc); 
 
    }
 
    public HighState(byte[] data) throws IOException
    {
        this(new LCMDataInputStream(data));
    }
 
    public HighState(DataInput ins) throws IOException
    {
        if (ins.readLong() != LCM_FINGERPRINT)
            throw new IOException("LCM Decode error: bad fingerprint");
 
        _decodeRecursive(ins);
    }
 
    public static slam_planner.HighState _decodeRecursiveFactory(DataInput ins) throws IOException
    {
        slam_planner.HighState o = new slam_planner.HighState();
        o._decodeRecursive(ins);
        return o;
    }
 
    public void _decodeRecursive(DataInput ins) throws IOException
    {
        this.levelFlag = ins.readByte();
 
        this.commVersion = ins.readShort();
 
        this.robotID = ins.readShort();
 
        this.SN = ins.readInt();
 
        this.bandWidth = ins.readByte();
 
        this.mode = ins.readByte();
 
        this.imu = slam_planner.IMU._decodeRecursiveFactory(ins);
 
        this.forwardSpeed = ins.readFloat();
 
        this.sideSpeed = ins.readFloat();
 
        this.rotateSpeed = ins.readFloat();
 
        this.bodyHeight = ins.readFloat();
 
        this.updownSpeed = ins.readFloat();
 
        this.forwardPosition = ins.readFloat();
 
        this.sidePosition = ins.readFloat();
 
        this.footPosition2Body = new slam_planner.Cartesian[(int) 4];
        for (int a = 0; a < 4; a++) {
            this.footPosition2Body[a] = slam_planner.Cartesian._decodeRecursiveFactory(ins);
        }
 
        this.footSpeed2Body = new slam_planner.Cartesian[(int) 4];
        for (int a = 0; a < 4; a++) {
            this.footSpeed2Body[a] = slam_planner.Cartesian._decodeRecursiveFactory(ins);
        }
 
        this.footForce = new short[(int) 4];
        for (int a = 0; a < 4; a++) {
            this.footForce[a] = ins.readShort();
        }
 
        this.footForceEst = new short[(int) 4];
        for (int a = 0; a < 4; a++) {
            this.footForceEst[a] = ins.readShort();
        }
 
        this.tick = ins.readInt();
 
        this.wirelessRemote = new byte[(int) 40];
        ins.readFully(this.wirelessRemote, 0, 40); 
        this.reserve = ins.readInt();
 
        this.crc = ins.readInt();
 
    }
 
    public slam_planner.HighState copy()
    {
        slam_planner.HighState outobj = new slam_planner.HighState();
        outobj.levelFlag = this.levelFlag;
 
        outobj.commVersion = this.commVersion;
 
        outobj.robotID = this.robotID;
 
        outobj.SN = this.SN;
 
        outobj.bandWidth = this.bandWidth;
 
        outobj.mode = this.mode;
 
        outobj.imu = this.imu.copy();
 
        outobj.forwardSpeed = this.forwardSpeed;
 
        outobj.sideSpeed = this.sideSpeed;
 
        outobj.rotateSpeed = this.rotateSpeed;
 
        outobj.bodyHeight = this.bodyHeight;
 
        outobj.updownSpeed = this.updownSpeed;
 
        outobj.forwardPosition = this.forwardPosition;
 
        outobj.sidePosition = this.sidePosition;
 
        outobj.footPosition2Body = new slam_planner.Cartesian[(int) 4];
        for (int a = 0; a < 4; a++) {
            outobj.footPosition2Body[a] = this.footPosition2Body[a].copy();
        }
 
        outobj.footSpeed2Body = new slam_planner.Cartesian[(int) 4];
        for (int a = 0; a < 4; a++) {
            outobj.footSpeed2Body[a] = this.footSpeed2Body[a].copy();
        }
 
        outobj.footForce = new short[(int) 4];
        System.arraycopy(this.footForce, 0, outobj.footForce, 0, 4); 
        outobj.footForceEst = new short[(int) 4];
        System.arraycopy(this.footForceEst, 0, outobj.footForceEst, 0, 4); 
        outobj.tick = this.tick;
 
        outobj.wirelessRemote = new byte[(int) 40];
        System.arraycopy(this.wirelessRemote, 0, outobj.wirelessRemote, 0, 40); 
        outobj.reserve = this.reserve;
 
        outobj.crc = this.crc;
 
        return outobj;
    }
 
}

